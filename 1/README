issue.pdf中题的密文：
(a)：C=001111010010011011110111100011111110000100011110010001011101110110001101101011110110001000011101
(b)：C=100010101100010010011000100101010100001001000100110101100111001001101110010010110010100010000101
(c)：C=100001000110101110000010001101100110001011100001110000000110000011010001011001100111000010101010
(d)：C=01110011001001000101110100000000101001011100000000110000000110101010101011101100000100110001111100100011100001111010100110000110
(e)：C=01100001010010010110101001010101001011110110010001011000110011011111111101111001001101010000100000111110100110110010110011110001
(f)：C=10000010000111010111001101110110011110110100001101111111100111101110000111101011101011111001010011001101100111001001000111100100
(g)：C=1110011001110001110000110010100101000011000110101010110011001101010110001101001111100001000100101011000011011010001001110110110000110100001010100101111001111001
(h)：C=0011100001101100101000110110011101010101001111010001110010111111110110111000100000100010001001111000111110101001010101001011101001001001111000111101001011001010

程序编译运行环境：Windows 7 x64 VS2010
程序开发语言：C++
程序源码文件：main.cpp(唯一源码文件)

程序运行调试方式：
在main函数中仿照已有代码调用cipher函数，参数输入需要M,K,IV以及存储输出密文C的buffer地址。
注意：
1、M,K,IV所对应的字符串中只能包含0或1，不能包含其它的空格，竖线，分号等其他无关内容，且长度必须满足文档中提供的要求，即M是32的倍数，K是32，IV是32。
2、由于issue.pdf以及debug.pdf中的数据M最大为32bit*5，所以代码中为存储输出密文C所提供的buffer大小设置为了32*5+1=161(含一位'\0'的空间)，如果需要测试其它测试数据，需调整此buffer大小使其满足要求，否则会因buffer大小不足而导致数组越界，进而导致程序崩溃。

其它设计细节以及注意事项：
1、为了保证程序最大的兼容性，以及方便运行，日志输出部分采用了正常文本读写，没有使用log4cplus等，否则可能会由于需要依赖环境等，导致程序使用不方便。此程序直接编译运行即可。
2、由于编译器的版本可能不一致，可能会有一些问题，此代码在windows 7 x64 VS2010编译无问题，但是若使用VS2013或者VS2015，可能fopen会由于不安全进制使用(在VS2010中只是警告，但是仍可以使用)，如果在其它环境中fopen无法使用，可以考虑尝试让编译器忽略此错误，或者用fopen_s函数替换。但是由于fopen_s函数在某些版本较低的编译环境下不支持，所以程序仍使用fopen函数。另外，如果在linux下用g++等编译，可能会需要<stdbool.h>与<memory.h>头文件，此两个头文件在我使用的当前环境下不需要，已经注释掉，如在linux下编译需要，取消注释即可。
3、此程序代码中多次使用了assert断言，用于判断矩阵的规模，输入的参数长度，以及数据是否是4bit数据，文件指针是否非空等是否符合要求，方便于代码的调试。
4、此程序主体采用C编写，由于某些矩阵操作用C写不易实现，接口复杂，所以采用了c++ STL中的vector向量来实现，向量处理过程中，由于很多矩阵规模确定，所以用resize调整了vector的大小，而没有使用push_back函数，这样操作代码执行效率更高。
5、为了代码可移植以及可扩展性，为了防止以后的命名冲突等，所有内部使用的全局变量以及函数均使用static处理，只有对外开放的接口函数没有使用static，实际上在main函数中调用的所有函数为对外开放的端口，其他函数均为内部使用。
6、为了代码的健壮以及以后改写时尽可能少出错，能用const限定的均加入了const限定。
7、为了代码的执行效率考虑，常用的取数据的左半部分L0与右半部分R0的函数，均使用了inline内联限定，也可以考虑使用define修改为宏。
8、log日志输出部分是对fprintf的一种封装，采用了不定长参数，使得使用起来可以和printf函数有一致的风格，每次分组的6轮加密结果的L与R的中间结果会全部在日志文件"log.txt"中输出。
9、整体上，屏幕输出M,K,IV以及加密后的结果C，而日志文件，除了输出最终结果，还会输出中间结果。
10、为了方便在VS下编译调试查看结果，程序结束前使用了system("pause")使得不至于结果一闪而过，如果是在cmd或者是linux下操作，此函数可以删除。
11、程序中一般使用的是unsigned char和unsigned int,没有对这些变量单独做typedef。
12、在VS2010下，已处理所有警告，除了fopen函数的警告没做处理。
13、将很多常用操作封装成了函数，源码中所有函数的定义后均含有注释，说明了该函数的用途，此文档中不再详细列出每个函数的功能。

算法运行的具体原理：
1、初始化log输出相关的指针操作
2、计算0-15之间的所有逆元，实际上0没有逆元，0的逆元按照是0本身进行了处理；然后按照文档中给定的矩阵参数计算S盒，用于SubBytes操作，避免每次都进行矩阵运算，计算完后只需要每次查表即可。
3、初始化用于列混淆时的矩阵MixMat。
4、以上所有的初始化操作只需要进行一次，以下的操作才需要每次调用cipher函数时使用。
5、当给定M,K,IV后，首先对长度等进行判断，长度没问题后，将二进制字节流转化为一个Byte一个Byte的字节数组。
6、对于M的每32bit(4Byte)的一个分组，通过calEk函数完成对每个分组的加密操作。
7、对于每一个分组的加密操作，先根据给定的K，通过MultRoundKey函数，计算6轮加密所使用的对应的key矩阵。
8、计算出6轮加密所需要的key矩阵后，再进行6轮具体的加密操作。
9、在每轮加密操作过程中，先完成对数据进行L,R左右两部分的拆分，对R部分执行SubBytes操作，此处实际运行时，即通过查找S盒中对应的数据，来代替矩阵运算，提高代码执行效率。
10、然后执行MultRoundKey操作，即用之前计算出key矩阵中该轮所对应的子key矩阵与上一步所得到的矩阵做GF(2^4)域上的乘法。
11、然后执行MixColumns列混淆操作，通过MixColumns函数把完成另一个矩阵的乘法。
12、之后执行ShiftRows操作，通过ShiftRows函数完成矩阵中指定的两个数据的互换位置操作。
13、最后，将该轮原始的R部分作为下一轮的L部分，将原始的L与上一步算出来的操作后的R部分做矩阵加法运算，实际就是异或运算。
14、继续完成下一轮操作，直到完成6轮操作为止。
15、最后，通过CFB模式，完成不同分组间的重组，即第一分组中，是对IV进行Ek加密操作，即calEk函数，Ek加密后的结果与明文M的第一个分组进行加法(异或)运算得到第一组密文C，以后的分组中，均对上一分组的密文C进行Ek加密操作，然后与当前分组的明文M做加法(异或)操作，直到所有分组处理完，将每组的密文C顺序拼接即可。
16、当所有的测试加密数据均完成后，关闭log日志文件，准备程序的退出。

其他问题：
由于SubBytes过程中，矩阵设置的参数问题，导致在求得的S盒中，S盒内的数据是有重复的，不唯一，这将导致逆S盒无法求解，也就是说，在加密过程中，SubBytes操作中会出现多对一的情况，这样在加密过程中没有问题，但是反过来解密时，就会出现一对多的情况，即可能会有同一段密文可以对应多段明文的情况，会导致无法解密。所以，此参数设置的最终导致的结果就是，只能加密无法解密。
